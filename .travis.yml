---
sudo: required
dist: bionic
env:
  global:
  # auto vagrant installation
  - VAGRANT_CURRENT_VERSION="$(curl -s https://checkpoint-api.hashicorp.com/v1/check/vagrant | jq -r -M '.current_version')"    
  # auto vagrant installation
  - VAGRANT_VERSION="2.2.9"
  - KUBECTL_VERSION=1.18.3
  - KUBERNETES_VERSION=1.18.3
  - MINIKUBE_VERSION=1.8.3
  - CHANGE_MINIKUBE_NONE_USER=true #(bool) automatically change ownership of ~/.minikube to the value of $SUDO_USER https://minikube.sigs.k8s.io/docs/handbook/config/
  - MINIKUBE_WANTREPORTERRORPROMPT=false
  - MINIKUBE_WANTUPDATENOTIFICATION=false #(bool) sets whether the user wants an update notification for new minikube versions https://minikube.sigs.k8s.io/docs/handbook/config
  - MINIKUBE_HOME=$HOME #(string) sets the path for the .minikube directory that minikube uses for state/configuration. Please note: this is used only by minikube https://minikube.sigs.k8s.io/docs/handbook/config
  - KUBECONFIG=$HOME/.kube/config

notifications:
  slack:
    on_failure: always

fleet_script_minikube_latest_tasks : &fleet_script_minikube_latest_tasks
      script:
          - |
            set -eo pipefail #safety for script
            if [[ $(egrep -c '(vmx|svm)' /proc/cpuinfo) == 0 ]]; then #check if virtualization is supported on Linux, xenial fails w 0, bionic works w 2
                     echo "virtualization is not supported"
            else
                  echo "===================================="
                  echo eval "$(egrep -c '(vmx|svm)' /proc/cpuinfo)" 2>/dev/null
                  echo "===================================="
                  echo "virtualization is supported"
            fi
          - sudo apt-get -qq -y install conntrack #X Sorry, Kubernetes v1.18.3 requires conntrack to be installed in root's path
          - curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - mkdir -p $HOME/.kube $HOME/.minikube
          - touch $KUBECONFIG
          - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          - minikube update-context --profile=minikube
          - "sudo chown -R travis: /home/travis/.minikube/"
          - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - kubectl version --client #ensure the version
          - kubectl cluster-info
          - minikube status
          - echo "=========================================================================================="
          - |
            echo "Waiting for Kubernetes to be ready ..."
            for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
              if kubectl get pods --namespace=kube-system -lcomponent=kube-addon-manager|grep Running && \
                 kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
                break
              fi
              sleep 2
            done
          - echo "============================status check=============================================================="
          - minikube status
          - kubectl cluster-info
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - echo "=========================================================================================="
          - echo "=============================Inspection============================================================="
          - echo "=========================================================================================="
          - kubectl get pod -o wide #The IP column will contain the internal cluster IP address for each pod.
          - kubectl get service --all-namespaces # find a Service IP,list all services in all namespaces
          - docker ps #Find the container ID or name of any container in the pod
          # - docker inspect --format '{{ .State.Pid }}' container-id-or-name #get the process ID of either container, take note of the container ID or name
          # - nsenter -t your-container-pid -n ip addr #advantage of using nsenter to run commands in a pod’s namespace – versus using something like docker exec – is that you have access to all of the commands available on the node
          # - nsenter -t your-container-pid -n ip addr #Finding a Pod’s Virtual Ethernet Interface
          # - curl $CONTAINERIP:8080 #confirm that the web server is still running on port 8080 on the container and accessible from the node
          - echo "=============================Inspecting Conntrack Connection Tracking============================================================="
          # - sudo apt-get -qq -y install conntrack #http://conntrack-tools.netfilter.org/
          - sudo apt-get -qq -y install bridge-utils # Install Linux Bridge Tools.
          - sudo apt-get -qq -y install tcpdump
          - sudo ip address show #List your networking devices
          - sudo ip netns list # list configured network namespaces
          - sudo ip netns add demo-ns #add a namespace called demo-ns
          - sudo ip netns list #see that it's in the list of available namespaces
          #A network namespace is a segregated network environment, complete with its own network stack
          # - echo "=============================start bash in our new namespace demo-ns============================================================="
          # - sudo ip netns exec demo-ns bash #start bash in our new namespace and look for interfaces that it knows about
          # - ping 8.8.8.8 #ping Google's public DNS server
          # #Observe that we have no route out of the namespace, so we don't know how to get to 8.8.8.8 from here
          # - netstat -rn #Check the routes that this namespace knows about
          # # - sudo tcpdump -ni veth0  icmp -c 4 #Confirm that the ping is still running and that both veth0 and cbr0 can see the ICMP packets in the default namespace
          # # - sudo tcpdump -ni eth0  icmp -c 4 #Now check whether eth0 can see the ICMP packets
          # # - sudo sysctl net.ipv4.conf.all.forwarding=1 #Turn forwarding on,Linux, by default, doesn't forward packets between interfaces
          # # - sudo tcpdump -ni eth0  icmp -c 4 #run tcpdump against eth0 to see if fw is working
          # # - sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE #make all outgoing packets from the host look like they're coming from the host's eth0 IP address
          # # - sudo tcpdump -ni eth0  icmp # sniff
          # # - sudo conntrack -L |grep 8.8.8.8 #iptables applies new rules to new flows and leaves ongoing flows alone
          # - ip address show
          # - ip route show
          # - sudo arp #Let's understand how the connectivity looks from the namespace's layer 2 perspective. Confirm that, from demo-ns, the MAC address of192.168.255.1
          # - ping 192.168.255.1 #Attempt to to ping cbr0,From this namespace, we can only see a local loopback interface. We can no longer see or ping eth0 or cbr0.
          # - exit #Exit out of the demo-ns namespace
          # - echo "=============================Exit out of the demo-ns namespace ============================================================="
          - ip address show #Confirm that you can see the interfaces in the default namespace
          - sudo arp #Confirm that you can see the interfaces in the default namespace
          - sudo tcpdump -ni ens4 icmp -c 4 #Confirm that you can see the interfaces in the default namespace
          - sudo conntrack -L | grep 8.8.8.8
          - conntrack -L #list all the connections currently being tracked
          - conntrack -E && sleep 5 #watch continuously for new connections
          # - conntrack -L -f ipv4 -d IPADDRESS -o extended #grep conntrack table information using the source IP and Port
          # - kubectl get po — all-namespaces -o wide | grep IPADDRESS #use kubectl to lookup the name of the pod using that Pod IP address
          # - conntrack -D -p tcp --orig-port-dst 80 # delete the relevant conntrack state
          # - sudo conntrack -D -s IPADDRESS
          # - conntrack -L -d IPADDRESS #list conntrack-tracked connections to a particular destination address
          - echo "=============================Inspecting Iptables Rules============================================================="
          - sysctl net.netfilter.nf_conntrack_max #sysctl setting for the maximum number of connections to track
          - sudo sysctl -w net.netfilter.nf_conntrack_max=191000 #set a new valu
          - sudo iptables-save | ead -n 20 #dump all iptables rules on a node
          - iptables -t nat -L KUBE-SERVICES #list just the Kubernetes Service NAT rules
          - echo "=============================Querying Cluster DNS============================================================="
          - sudo apt install dnsutils -y #if dig is not installed
          - kubectl get service -n kube-system kube-dns #find the cluster IP of the kube-dns service CLUSTER-IP
          # - nsenter -t 14346 -n dig kubernetes.default.svc.cluster.local @IPADDRESS #nsenter to run dig in the a container namespace, Service’s full domain name of service-name.namespace.svc.cluster.local
          - ipvsadm -Ln #list the translation table of IPs ,kube-proxy can configure IPVS to handle the translation of virtual Service IPs to pod IPs
          # - ipvsadm -Ln -t IPADDRESS:PORT #show a single Service IP
          - echo "=========================================================================================="
fleet_script_minikube_tasks : &fleet_script_minikube_tasks
      script:
          # overriding global env variables
          - |
            set -eo pipefail #safety for script
            if [[ $(egrep -c '(vmx|svm)' /proc/cpuinfo) == 0 ]]; then #check if virtualization is supported on Linux, xenial fails w 0, bionic works w 2
                     echo "virtualization is not supported"
            else
                  echo "===================================="
                  echo eval "$(egrep -c '(vmx|svm)' /proc/cpuinfo)" 2>/dev/null
                  echo "===================================="
                  echo "virtualization is supported"
            fi
          - export MINIKUBE_WANTUPDATENOTIFICATION=false
          - export MINIKUBE_WANTREPORTERRORPROMPT=false
          - export CHANGE_MINIKUBE_NONE_USER=true
          - export KUBECTL_VERSION=1.18.3
          - export KUBERNETES_VERSION=1.18.3
          - export MINIKUBE_VERSION=1.18.3
          - sudo apt-get -qq -y install conntrack #X Sorry, Kubernetes v1.18.3 requires conntrack to be installed in root's path
          - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v$KUBECTL_VERSION/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v$MINIKUBE_VERSION/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - mkdir -p $HOME/.kube $HOME/.minikube
          - touch $KUBECONFIG
          - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #--vm-driver=none, doesn't use a VM, but containers the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          - minikube update-context --profile=minikube
          - "sudo chown -R travis: /home/travis/.minikube/"
          - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - kubectl version --client #ensure the version
          - kubectl cluster-info
          - minikube status
          - echo "=========================================================================================="
          - |
            echo "Waiting for Kubernetes to be ready ..."
            for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
              if kubectl get pods --namespace=kube-system -lcomponent=kube-addon-manager|grep Running && \
                 kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
                break
              fi
              sleep 2
            done
          - |
            JSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}';
            until kubectl -n kube-system get pods -lk8s-app=kube-dns -o jsonpath="$JSONPATH" 2>&1 | grep -q "Ready=True"; do
              sleep 1;
              echo "waiting for kube-dns to be available";
              kubectl get pods --all-namespaces;
            done
          - kubectl run travis-example --image=redis --labels="app=travis-example" # Create example Redis deployment on Kubernetes.
          - | # Make sure created pod is scheduled and running.
            JSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}';
            until kubectl -n default get pods -lapp=travis-example -o jsonpath="$JSONPATH" 2>&1 | grep -q "Ready=True"; do
              sleep 1;
              echo "waiting for travis-example deployment to be available";
              kubectl get pods -n default;
            done
          - echo "============================================="
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - echo "============================================="
fleet_script_tasks : &fleet_script_tasks
      script:
        - python --version
fleet_install_tasks : &fleet_install_tasks
      install:
        - pip install -r requirements.txt


matrix:
  fast_finish: true
  include:


    # - name: "minikube 1.18.1 Python 3.7 on bionic"
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_minikube_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "minikube 1.18.1 Python 3.7 on xenial"
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_minikube_tasks
    #   after_success:
    #     - deactivate

    - name: "minikube latest  Python 3.7 on bionic" #OK
      dist: bionic
      language: python
      python: 3.7
      before_install:
        - pip3 install virtualenv
        - virtualenv -p $(which python3) ~venvpy3
        - source ~venvpy3/bin/activate
      <<: *fleet_install_tasks
      <<: *fleet_script_tasks
      <<: *fleet_script_minikube_latest_tasks
      after_success:
        - deactivate

    - name: "minikube latest  Python 3.7 on xenial" #OK
      dist: xenial
      language: python
      python: 3.7
      before_install:
        - pip3 install virtualenv
        - virtualenv -p $(which python3) ~venvpy3
        - source ~venvpy3/bin/activate
      <<: *fleet_install_tasks
      <<: *fleet_script_tasks
      <<: *fleet_script_minikube_latest_tasks
      after_success:
        - deactivate

    # - name: "Python 3.7 on bionic arm64" # package architecture (amd64) does not match system (arm64)
    #   os: linux
    #   arch: arm64
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on bionic ppc64le" #Unable to locate package osquery
    #   os: linux
    #   arch: ppc64le
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on bionic s390x" #Unable to locate package osquery
    #   os: linux
    #   arch: s390x
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate


    # - name: "Python 2.7 on xenial amd64"
    #   dist: xenial
    #   language: python
    #   python: 2.7
    #   before_install:
    #     - pip install virtualenv
    #     - virtualenv -p $(which python2) ~venvpy2
    #     - source ~venvpy2/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #
    #   after_success:
    #     - deactivate

    # - name: "Python 3.7 on xenial arm64"
    #   os: linux
    #   arch: arm64
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on xenial ppc64le" #Unable to locate package osquery
    #   os: linux
    #   arch: ppc64le
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on xenial s390x" #Unable to locate package osquery
    #   os: linux
    #   arch: s390x
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate




    # - name: "Python 2.7.17 on macOS xcode10.2"
    #   os: osx
    #   osx_image: xcode10.2
    #   language: shell
    #   before_install:
    #     - pip install virtualenv
    #     - virtualenv -p $(which python2) ~venvpy2
    #     - source ~venvpy2/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   after_success:
    #     - deactivate
    #
    #
    #
    #
    # - name: "Python 3.7.5 on macOS xcode10.2"
    #   os: osx
    #   osx_image: xcode10.2
    #   language: shell
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7.5 on macOS xcode9.4 "
    #   os: osx
    #   osx_image: xcode9.4
    #   language: shell
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   after_success:
    #     - deactivate



    # - name: "Python 3.8 on Windows"
    #   os: windows
    #   language: shell
    #   env:
    #     - PATH=/c/Python38:/c/Python38/Scripts:$PATH
    #   before_install:
    #     - choco install python --version 3.8.1
    #     - pip install virtualenv
    #     - virtualenv $HOME/venv
    #     - source $HOME/venv/Scripts/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on Windows"
    #   os: windows
    #   language: shell
    #   env: PATH=/c/Python37:/c/Python37/Scripts:$PATH
    #   before_install:
    #     - choco install python --version 3.7.3
    #     - python -m pip install virtualenv
    #     - virtualenv $HOME/venv
    #     - source $HOME/venv/Scripts/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   after_success:
    #     - deactivate
