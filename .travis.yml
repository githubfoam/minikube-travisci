---
sudo: required
dist: bionic
env:
  global:
  - VAGRANT_VERSION="2.2.9"
  - MINIKUBE_WANTUPDATENOTIFICATION=false #(bool) sets whether the user wants an update notification for new minikube versions https://minikube.sigs.k8s.io/docs/handbook/config
  - MINIKUBE_WANTREPORTERRORPROMPT=false
  - CHANGE_MINIKUBE_NONE_USER=true #(bool) automatically change ownership of ~/.minikube to the value of $SUDO_USER https://minikube.sigs.k8s.io/docs/handbook/config/
  - KUBECTL_VERSION=1.18.3
  - KUBERNETES_VERSION=1.18.3
  - MINIKUBE_VERSION=1.8.3
  - MINIKUBE_HOME=$HOME #(string) sets the path for the .minikube directory that minikube uses for state/configuration. Please note: this is used only by minikube https://minikube.sigs.k8s.io/docs/handbook/config
  - KUBECONFIG=$HOME/.kube/config

notifications:
  slack:
    on_failure: always


fleet_script_minikube_latest_app_tasks : &fleet_script_minikube_latest_app_tasks
      script:
          # - set -eox pipefail #safety for script
          - |
            if [[ $(egrep -c '(vmx|svm)' /proc/cpuinfo) == 0 ]]; then #check if virtualization is supported on Linux, xenial fails w 0, bionic works w 2
                     echo "virtualization is not supported"
            else
                  echo "===================================="
                  echo eval "$(egrep -c '(vmx|svm)' /proc/cpuinfo)" 2>/dev/null
                  echo "===================================="
                  echo "virtualization is supported"
            fi
          - sudo apt-get -qq -y install conntrack #http://conntrack-tools.netfilter.org/
          - curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - mkdir -p $HOME/.kube $HOME/.minikube
          - touch $KUBECONFIG
          - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root userâ€™s home directory
          - minikube update-context --profile=minikube
          - "sudo chown -R travis: /home/travis/.minikube/"
          - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - kubectl version --client #ensure the version
          - kubectl cluster-info
          - minikube status
          - echo "=========================================================================================="
          - |
            echo "Waiting for Kubernetes to be ready ..."
            for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
              if kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
                break
              fi
              sleep 2
            done
          # - |
          #   echo "Waiting for Kubernetes to be ready ..."
          #   for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
          #     if kubectl get pods --namespace=kube-system -lcomponent=kube-addon-manager|grep Running && \
          #        kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
          #       break
          #     fi
          #     sleep 2
          #   done
          - echo "============================status check=============================================================="
          - minikube status
          - kubectl cluster-info
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - echo "=============================Inspection============================================================="
          - kubectl get pod -o wide #The IP column will contain the internal cluster IP address for each pod.
          - kubectl get service --all-namespaces # find a Service IP,list all services in all namespaces
          - echo "=============================openEBS============================================================="
          - pushd $(pwd) && cd app
          - sudo kubectl apply -f https://openebs.github.io/charts/openebs-operator.yaml #install OpenEBS
          - kubectl get service --all-namespaces # find a Service IP,list all services in all namespaces
          - kubectl get pods -n openebs -l openebs.io/component-name=openebs-localpv-provisioner #Observe localhost provisioner pod
          - kubectl get sc #Check the storage Class
          # openesb component list
          #https://github.com/openebs/openebs/blob/master/k8s/openebs-operator.yaml
          - |
            echo "Waiting for openebs-localpv-provisioner component to be ready ..."
            for i in {1..60}; do # Timeout after 5 minutes, 150x5=300 secs
                if sudo kubectl get pods --namespace=openebs -l openebs.io/component-name=openebs-localpv-provisioner | grep Running ; then
                  break
                fi
                sleep 5
            done
          - |
            echo "Waiting for maya-apiserver component to be ready ..."
            for i in {1..60}; do # Timeout after 5 minutes, 150x5=300 secs
                if sudo kubectl get pods --namespace=openebs -l openebs.io/component-name=maya-apiserver | grep Running ; then
                  break
                fi
                sleep 5
            done
          - |
            echo "Waiting for openebs-ndm-operator component to be ready ..."
            for i in {1..60}; do # Timeout after 5 minutes, 150x5=300 secs
                if sudo kubectl get pods --namespace=openebs -l openebs.io/component-name=openebs-ndm-operator | grep Running ; then
                  break
                fi
                sleep 5
            done
          - |
            echo "Waiting for openebs to be ready ..."
            for i in {1..60}; do # Timeout after 2 minutes, 60x2=300 secs
                if sudo kubectl get pods --namespace=openebs | grep Running ; then
                  break
                fi
                sleep 2
            done
          - sudo kubectl get pods --all-namespaces
          - sudo kubectl get pods --namespace=openebs
          - popd
          - echo "=============================openEBS============================================================="
          #Create a PVC #Create an Nginx Pod which consumes OpenEBS Local PV Hospath Storage #openEBS
          #HPA
          # - pushd $(pwd) && cd hpa
          # - minikube addons list
          # - sudo minikube addons enable metrics-server
          # - minikube addons list
          # - sudo kubectl get pods -n kube-system
          # - sudo kubectl logs -n kube-system deploy/metrics-server
          # - sudo kubectl get svc -n kube-system
          # # - sudo ping 10.96.56.228 -c 1 # ping metrics-server   ClusterIP
          # - kubectl get pods -n kube-system -o wide
          # - ping 10.224.13.23 -c 1 #   # ping metrics-server  pod IP
          # - sudo systemctl status kube-apiserver -l
          # - sudo kubectl top node
          # - sudo kubectl top pod
          # - sudo kubectl describe hpa
          # - |
          #   sudo minikube start \
          #   --extra-config=controller-manager.horizontal-pod-autoscaler-upscale-delay=1m \
          #   --extra-config=controller-manager.horizontal-pod-autoscaler-downscale-delay=1m \
          #   --extra-config=controller-manager.horizontal-pod-autoscaler-sync-period=10s \
          #   --extra-config=controller-manager.horizontal-pod-autoscaler-downscale-stabilization=1m
          # - sudo kubectl autoscale deployment php-apache --cpu-percent=50 --min=1 --max=10
          # - sudo kubectl run --generator=run-pod/v1 -it --rm load-generator --image=busybox /bin/sh #Load generator
          # - while true; do wget -q -O- http://php-apache; done
          # - kubectl get --raw /apis/metrics.k8s.io/v1beta1
          # - kubectl get pods -n kube-system | grep metrics-server
          # - kubectl get --raw /apis/metrics.k8s.io/v1beta1/nodes | jq '.'
          # - kubectl get --raw /apis/metrics.k8s.io/v1beta1/pods | jq '.'
          # - |
          #   kubectl get --raw /apis/metrics.k8s.io/v1beta1/nodes \
          #   | jq '[.items [] | {nodeName: .metadata.name, nodeCpu: .usage.cpu, nodeMemory: .usage.memory}]'
          # - popd
          #HPA
          # #nfs-pv-storage
          - pushd $(pwd) && cd nfs-pv-storage
          - sudo apt install nfs-kernel-server
          - sudo mkdir -p /pv/nfs/test-volume
          - sudo chmod 777 /pv/nfs/test-volume
          - sudo systemctl status nfs-server
          - sudo systemctl stop nfs-server
          - sudo systemctl start nfs-server
          - sudo systemctl restart nfs-server
          # - sudo vi /etc/exports
          # /mnt/nfs/test-volume *(rw,sync,no_subtree_check,insecure)
          # /pv/nfs/test-volume *(rw,sync,no_subtree_check,insecure)
          # - sudo exportfs -a
          # - sudo exportfs -v
          # - sudo kubectl expose deploy nginx-deploy --port 80 --type NodePort
          # - sudo apt-get update
          # - sudo apt-get install -qqy curl
          # - curl http://localhost/
          - popd
          # #nfs-pv-storage
          # #NGINX as a sample application
          # - sudo kubectl create deployment nginx --image=nginx
          # - sudo kubectl get deployments
          # - sudo kubectl get pods
          # - sudo kubectl get all --all-namespaces
          # #NGINX as a sample application

# fleet_script_minikube_latest_bluegreen_tasks : &fleet_script_minikube_latest_bluegreen_tasks
#       script:
          # # - set -eox pipefail #safety for script
          # - |
          #   if [[ $(egrep -c '(vmx|svm)' /proc/cpuinfo) == 0 ]]; then #check if virtualization is supported on Linux, xenial fails w 0, bionic works w 2
          #            echo "virtualization is not supported"
          #   else
          #         echo "===================================="
          #         echo eval "$(egrep -c '(vmx|svm)' /proc/cpuinfo)" 2>/dev/null
          #         echo "===================================="
          #         echo "virtualization is supported"
          #   fi
          # - sudo apt-get -qq -y install conntrack #http://conntrack-tools.netfilter.org/
          # - curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          # - curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          # - mkdir -p $HOME/.kube $HOME/.minikube
          # - touch $KUBECONFIG
          # - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root userâ€™s home directory
          # - minikube update-context --profile=minikube
          # - "sudo chown -R travis: /home/travis/.minikube/"
          # - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          # - echo "=========================================================================================="
          # - kubectl version --client #ensure the version
          # - kubectl cluster-info
          # - minikube status
          # - echo "=========================================================================================="
          # - |
          #   echo "Waiting for Kubernetes to be ready ..."
          #   for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
          #     if kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
          #       break
          #     fi
          #     sleep 2
          #   done
          # # - |
          # #   echo "Waiting for Kubernetes to be ready ..."
          # #   for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
          # #     if kubectl get pods --namespace=kube-system -lcomponent=kube-addon-manager|grep Running && \
          # #        kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
          # #       break
          # #     fi
          # #     sleep 2
          # #   done
          # - echo "============================status check=============================================================="
          # - minikube status
          # - kubectl cluster-info
          # - kubectl get pods --all-namespaces;
          # - kubectl get pods -n default;
          # - echo "=============================Inspection============================================================="
          # - kubectl get pod -o wide #The IP column will contain the internal cluster IP address for each pod.
          # - kubectl get service --all-namespaces # find a Service IP,list all services in all namespaces
          # #BLUE
          # - pushd $(pwd) && cd blue
          # - docker image ls && docker container ls
          # - export DOCKER_IMAGE="testblueimage"
          # - export DOCKER_REPO="bluerepo"
          # # - export IMAGE_TAG=$DOCKER_IMAGE:$TRAVIS_COMMIT
          # - sudo docker build -t $DOCKER_IMAGE:$TRAVIS_COMMIT . --file=Dockerfile.nginx
          # # - sudo docker build -t $DOCKER_IMAGE:$TRAVIS_COMMIT
          # # DOCKER_TOKEN DOCKER_USERNAME are defined on travisci environment variables section
          # - echo $DOCKER_TOKEN | sudo docker login --username $DOCKER_USERNAME --password-stdin #Login Succeeded
          # # - sudo docker login -u="$DOCKER_USERNAME" -p="$DOCKER_TOKEN" #Login Succeeded
          # - echo $TRAVIS_COMMIT
          # - echo $TRAVIS_TAG
          # - git_sha="${TRAVIS_COMMIT}"
          # - sudo docker tag $DOCKER_IMAGE:$TRAVIS_COMMIT "$DOCKER_USERNAME/$DOCKER_REPO:${git_sha}-${TRAVIS_BRANCH}"
          # - sudo docker push "$DOCKER_USERNAME/$DOCKER_REPO:${git_sha}-${TRAVIS_BRANCH}"
          # # - sudo docker tag $DOCKER_IMAGE:$TRAVIS_COMMIT "dockerfoam/bluerepo:$DOCKER_IMAGE"
          # # - sudo docker push "dockerfoam/bluerepo:$DOCKER_IMAGE"
          # # - sudo docker run -d "dockerfoam/bluerepo:$DOCKER_IMAGE"
          # - sudo docker run -p 8000:80 "$DOCKER_USERNAME/$DOCKER_REPO:$DOCKER_IMAGE" &
          # - sudo docker image ls
          # - sudo docker container ls
          # - sudo docker logout
          # - popd
          # #BLUE
          # #GREEN
          # - pushd $(pwd) && cd green
          # - export DOCKER_IMAGE="testgreenimage"
          # - export DOCKER_REPO="greenrepo"
          # - sudo docker build -t $DOCKER_IMAGE:$TRAVIS_COMMIT . --file=Dockerfile.nginx
          # - echo $DOCKER_TOKEN | sudo docker login --username $DOCKER_USERNAME --password-stdin #Login Succeeded
          # - git_sha="${TRAVIS_COMMIT}"
          # - sudo docker tag $DOCKER_IMAGE:$TRAVIS_COMMIT "$DOCKER_USERNAME/$DOCKER_REPO:${git_sha}-${TRAVIS_BRANCH}"
          # - sudo docker push "$DOCKER_USERNAME/$DOCKER_REPO:${git_sha}-${TRAVIS_BRANCH}"
          # - sudo docker run -p 8000:80 "$DOCKER_USERNAME/$DOCKER_REPO:$DOCKER_IMAGE" &
          # - sudo docker image ls
          # - sudo docker container ls
          # - sudo docker logout
          # - popd
          # #GREEN
          # - pushd $(pwd) && cd blue
          # - sudo kubectl apply -f ./blue-controller.json #Create a replication controller blue pod
          # - popd
          # - pushd $(pwd) && cd green
          # - sudo kubectl apply -f green-controller.json #Create a replication controller green pod
          # - popd
          # - sudo kubectl apply -f ./blue-green-service.json #Create the service, redirect to blue and make it externally visible, specify "type": "LoadBalancer"
          # - echo "=========================================================================================="
          # - |
          #   echo "Waiting for Kubernetes to be ready ..."
          #   for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
          #     if kubectl get pods --namespace=default -lk8s-app=blue |grep Running ; then
          #       break
          #     fi
          #     sleep 2
          #   done
          # - echo $(minikube service bluegreenlb --url) #debug mode http://10.30.0.90:31089
          # - serviceURL=$(minikube service bluegreenlb --url)
          # - minikube service bluegreenlb --url #Get the URL of the service by running
          # - curl $serviceURL #open the website blue in your browser by using the URL
          # # - curl $(minikube service bluegreenlb --url) #open the website blue in your browser by using the URL
          # #Update the service to redirect to green by changing the selector to app=green??
          # # - sudo kubectl apply -f ./blue-green-service.json #Create the service, redirect to blue and make it externally visible, specify "type": "LoadBalancer"
          # # - minikube service bluegreenlb --url #Get the URL of the service by running
          # # - curl $(minikube service bluegreenlb --url) #open the website blue in your browser by using the URL
          # - kubectl get pods --all-namespaces;
          # # - docker inspect --format '{{ .State.Pid }}' container-id-or-name #get the process ID of either container, take note of the container ID or name
          # - echo "=========================================================================================="

fleet_script_minikube_tasks : &fleet_script_minikube_tasks
      script:
          # overriding global env variables
          - $ egrep -c '(vmx|svm)' /proc/cpuinfo | echo "virtualization is  supported" | echo "virtualization is not supported"
          - export MINIKUBE_WANTUPDATENOTIFICATION=false
          - export MINIKUBE_WANTREPORTERRORPROMPT=false
          - export CHANGE_MINIKUBE_NONE_USER=true
          - export KUBECTL_VERSION=1.18.3
          - export KUBERNETES_VERSION=1.18.3
          - export MINIKUBE_VERSION=1.18.3
          - sudo apt-get -qq -y install conntrack #http://conntrack-tools.netfilter.org/
          - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v$KUBECTL_VERSION/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v$MINIKUBE_VERSION/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - mkdir -p $HOME/.kube $HOME/.minikube
          - touch $KUBECONFIG
          - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #--vm-driver=none, doesn't use a VM, but containers the none driver, the kubectl config and credentials generated are owned by root in the root userâ€™s home directory
          - minikube update-context --profile=minikube
          - "sudo chown -R travis: /home/travis/.minikube/"
          - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - kubectl version --client #ensure the version
          - kubectl cluster-info
          - minikube status
          - echo "=========================================================================================="
          - |
            echo "Waiting for Kubernetes to be ready ..."
            for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
              if kubectl get pods --namespace=kube-system -lcomponent=kube-addon-manager|grep Running && \
                 kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
                break
              fi
              sleep 2
            done
          - |
            JSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}';
            until kubectl -n kube-system get pods -lk8s-app=kube-dns -o jsonpath="$JSONPATH" 2>&1 | grep -q "Ready=True"; do
              sleep 1;
              echo "waiting for kube-dns to be available";
              kubectl get pods --all-namespaces;
            done
          - kubectl run travis-example --image=redis --labels="app=travis-example" # Create example Redis deployment on Kubernetes.
          - | # Make sure created pod is scheduled and running.
            JSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}';
            until kubectl -n default get pods -lapp=travis-example -o jsonpath="$JSONPATH" 2>&1 | grep -q "Ready=True"; do
              sleep 1;
              echo "waiting for travis-example deployment to be available";
              kubectl get pods -n default;
            done
          - echo "============================================="
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - echo "============================================="
# fleet_script_tasks : &fleet_script_tasks
#       script:
#         - python --version
# fleet_install_tasks : &fleet_install_tasks
#       install:
#         - pip install -r requirements.txt


matrix:
  fast_finish: true
  include:

    # - name: "openebs minikube latest  Python 3.7 on bionic amd64" #OK
    #   dist: bionic
    #   arch: amd64
    #   addons:
    #     snaps:
    #       - name: helm
    #         confinement: classic
    #         channel: latest/stable
    #       # - name: kubectl
    #       #   confinement: classic
    #       #   channel: latest/stable
    #       # - name: minikube
    #       #   confinement: classic
    #       #   channel: latest/stable
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   # <<: *fleet_script_minikube_latest_tasks
    #   # <<: *fleet_script_minikube_latest_app_tasks
    #   script:
    #     # - sudo make deploy-minikube
    #     # - sudo make deploy-openesb #OK
    #     - travis_wait 15 sudo make deploy-java-maven &
    #   after_success:
    #     - deactivate

    - name: "canary minikube latest  Python 3.7 on bionic amd64" #OK
      dist: bionic
      arch: amd64
      addons:
           snaps:
             - name: kubectl
               confinement: classic
               channel: latest/stable
      language: python
      python: 3.7
      before_install:
        - pip3 install virtualenv
        - virtualenv -p $(which python3) ~venvpy3
        - source ~venvpy3/bin/activate
        - pip install -r requirements.txt
      script:
        - sudo make deploy-minikube
        - sudo make deploy-minikube-latest-canary
      after_success:
        - deactivate

    - name: "blue green minikube latest  Python 3.7 on bionic amd64" #OK
      dist: bionic
      arch: amd64
      addons:
           snaps:
             - name: kubectl
               confinement: classic
               channel: latest/stable
      language: python
      python: 3.7
      before_install:
        - pip3 install virtualenv
        - virtualenv -p $(which python3) ~venvpy3
        - source ~venvpy3/bin/activate
        - pip install -r requirements.txt
      # <<: *fleet_install_tasks
      # <<: *fleet_script_tasks
      # <<: *fleet_script_minikube_latest_bluegreen_tasks
      script:
        # - sudo make deploy-minikube
        - sudo make deploy-minikube-latest-bluegreen
      after_success:
        - deactivate

    # - name: "minikube latest  Python 3.7 on xenial" #OK
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_minikube_tasks
    #   after_success:
    #     - deactivate

    # - name: "Python 3.7 on bionic arm64" # package architecture (amd64) does not match system (arm64)
    #   os: linux
    #   arch: arm64
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on bionic ppc64le" #Unable to locate package osquery
    #   os: linux
    #   arch: ppc64le
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on bionic s390x" #Unable to locate package osquery
    #   os: linux
    #   arch: s390x
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate


    # - name: "Python 2.7 on xenial amd64"
    #   dist: xenial
    #   language: python
    #   python: 2.7
    #   before_install:
    #     - pip install virtualenv
    #     - virtualenv -p $(which python2) ~venvpy2
    #     - source ~venvpy2/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #
    #   after_success:
    #     - deactivate

    # - name: "Python 3.7 on xenial arm64"
    #   os: linux
    #   arch: arm64
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on xenial ppc64le" #Unable to locate package osquery
    #   os: linux
    #   arch: ppc64le
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on xenial s390x" #Unable to locate package osquery
    #   os: linux
    #   arch: s390x
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate




    # - name: "Python 2.7.17 on macOS xcode10.2"
    #   os: osx
    #   osx_image: xcode10.2
    #   language: shell
    #   before_install:
    #     - pip install virtualenv
    #     - virtualenv -p $(which python2) ~venvpy2
    #     - source ~venvpy2/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   after_success:
    #     - deactivate
    #
    #
    #
    #
    # - name: "Python 3.7.5 on macOS xcode10.2"
    #   os: osx
    #   osx_image: xcode10.2
    #   language: shell
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7.5 on macOS xcode9.4 "
    #   os: osx
    #   osx_image: xcode9.4
    #   language: shell
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   after_success:
    #     - deactivate



    # - name: "Python 3.8 on Windows"
    #   os: windows
    #   language: shell
    #   env:
    #     - PATH=/c/Python38:/c/Python38/Scripts:$PATH
    #   before_install:
    #     - choco install python --version 3.8.1
    #     - pip install virtualenv
    #     - virtualenv $HOME/venv
    #     - source $HOME/venv/Scripts/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on Windows"
    #   os: windows
    #   language: shell
    #   env: PATH=/c/Python37:/c/Python37/Scripts:$PATH
    #   before_install:
    #     - choco install python --version 3.7.3
    #     - python -m pip install virtualenv
    #     - virtualenv $HOME/venv
    #     - source $HOME/venv/Scripts/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   after_success:
    #     - deactivate
